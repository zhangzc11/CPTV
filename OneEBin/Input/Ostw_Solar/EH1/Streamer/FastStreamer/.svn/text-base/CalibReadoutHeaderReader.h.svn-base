//////////////////////////////////////////////////////////
// This class has been automatically generated on
// Tue Mar 20 15:10:07 2012 by ROOT version 5.30/02
// from TTree CalibReadoutHeader/Tree at /Event/CalibReadout/CalibReadoutHeader holding CalibReadout_CalibReadoutHeader
// found on file: /home/wangzhe/share/data/exp/recon.Neutrino.0021201.Physics.EH2-Merged.P12B-I._0001.root
//////////////////////////////////////////////////////////

#ifndef CalibReadoutHeaderReader_h
#define CalibReadoutHeaderReader_h

#include <TROOT.h>
#include <TChain.h>
#include <TFile.h>
#include <TSelector.h>
   const Int_t kMaxinputHeaders2 = 20;

#include <vector>
using namespace std;

class CalibReadoutHeaderReader : public TSelector {
public :
   TTree          *fChain;   //!pointer to the analyzed TTree or TChain

   // Declaration of leaf types
 //PerCalibReadoutHeader *CalibReadout_CalibReadoutHeader;
   Int_t           clID;
   Int_t           earliest_mSec;
   Int_t           earliest_mNanoSec;
   Int_t           latest_mSec;
   Int_t           latest_mNanoSec;
   Int_t           context_mSite;
   Int_t           context_mSimFlag;
   Int_t           context_mTimeStamp_mSec;
   Int_t           context_mTimeStamp_mNanoSec;
   Int_t           context_mDetId;
   Int_t           execNumber;
   UInt_t          jobId_m_data[4];
   vector<unsigned long> randomState;
   Int_t           inputHeaders_;
   Int_t           inputHeaders_m_entry[kMaxinputHeaders2];   //[inputHeaders_]
   string          inputHeaders_m_path[kMaxinputHeaders2];
   UInt_t          site;
   UInt_t          detector;
   UInt_t          triggerNumber;
   UInt_t          triggerType;
   UInt_t          triggerTimeSec;
   UInt_t          triggerTimeNanoSec;
   UInt_t          nHitsAD;
   vector<float>   timeAD;
   vector<float>   chargeAD;
   vector<unsigned int> hitCountAD;
   vector<unsigned int> ring;
   vector<unsigned int> column;
   UInt_t          nHitsAD_calib;
   vector<float>   timeAD_calib;
   vector<float>   chargeAD_calib;
   vector<unsigned int> hitCountAD_calib;
   vector<unsigned int> topOrBottom;
   vector<unsigned int> acuColumn;
   UInt_t          nHitsPool;
   vector<float>   timePool;
   vector<float>   chargePool;
   vector<unsigned int> hitCountPool;
   vector<unsigned int> wallNumber;
   vector<unsigned int> wallSpot;
   vector<unsigned int> inwardFacing;
   UInt_t          nHitsRpc;
   vector<unsigned int> rpcRow;
   vector<unsigned int> rpcColumn;
   vector<unsigned int> rpcLayer;
   vector<unsigned int> rpcStrip;
   vector<bool>    rpcFromRot;

   // List of branches
   TBranch        *b_CalibReadout_CalibReadoutHeader_clID;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_earliest_mSec;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_earliest_mNanoSec;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_latest_mSec;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_latest_mNanoSec;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_context_mSite;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_context_mSimFlag;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_context_mTimeStamp_mSec;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_context_mTimeStamp_mNanoSec;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_context_mDetId;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_execNumber;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_jobId_m_data;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_randomState;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_inputHeaders_;   //!
   TBranch        *b_inputHeaders_m_entry;   //!
   TBranch        *b_inputHeaders_m_path;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_site;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_detector;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_triggerNumber;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_triggerType;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_triggerTimeSec;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_triggerTimeNanoSec;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_nHitsAD;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_timeAD;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_chargeAD;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_hitCountAD;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_ring;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_column;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_nHitsAD_calib;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_timeAD_calib;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_chargeAD_calib;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_hitCountAD_calib;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_topOrBottom;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_acuColumn;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_nHitsPool;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_timePool;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_chargePool;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_hitCountPool;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_wallNumber;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_wallSpot;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_inwardFacing;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_nHitsRpc;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_rpcRow;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_rpcColumn;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_rpcLayer;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_rpcStrip;   //!
   TBranch        *b_CalibReadout_CalibReadoutHeader_rpcFromRot;   //!

   CalibReadoutHeaderReader(TTree * /*tree*/ =0) { }
   virtual ~CalibReadoutHeaderReader() { }
   virtual Int_t   Version() const { return 2; }
   virtual void    Begin(TTree *tree);
   virtual void    SlaveBegin(TTree *tree);
   virtual void    Init(TTree *tree);
   virtual Bool_t  Notify();
   virtual Bool_t  Process(Long64_t entry);
   virtual Int_t   GetEntry(Long64_t entry, Int_t getall = 0) { return fChain ? fChain->GetEntry(entry, getall) : 0; }
   virtual void    SetOption(const char *option) { fOption = option; }
   virtual void    SetObject(TObject *obj) { fObject = obj; }
   virtual void    SetInputList(TList *input) { fInput = input; }
   virtual TList  *GetOutputList() const { return fOutput; }
   virtual void    SlaveTerminate();
   virtual void    Terminate();

   ClassDef(CalibReadoutHeaderReader,0);
};

#endif

#ifdef CalibReadoutHeaderReader_cxx
void CalibReadoutHeaderReader::Init(TTree *tree)
{
   // The Init() function is called when the selector needs to initialize
   // a new tree or chain. Typically here the branch addresses and branch
   // pointers of the tree will be set.
   // It is normally not necessary to make changes to the generated
   // code, but the routine can be extended by the user if needed.
   // Init() will be called many times when running on PROOF
   // (once per file to be processed).

   // Set branch addresses and branch pointers
   if (!tree) return;
   fChain = tree;
   fChain->SetMakeClass(1);

   fChain->SetBranchAddress("clID", &clID, &b_CalibReadout_CalibReadoutHeader_clID);
   fChain->SetBranchAddress("earliest.mSec", &earliest_mSec, &b_CalibReadout_CalibReadoutHeader_earliest_mSec);
   fChain->SetBranchAddress("earliest.mNanoSec", &earliest_mNanoSec, &b_CalibReadout_CalibReadoutHeader_earliest_mNanoSec);
   fChain->SetBranchAddress("latest.mSec", &latest_mSec, &b_CalibReadout_CalibReadoutHeader_latest_mSec);
   fChain->SetBranchAddress("latest.mNanoSec", &latest_mNanoSec, &b_CalibReadout_CalibReadoutHeader_latest_mNanoSec);
   fChain->SetBranchAddress("context.mSite", &context_mSite, &b_CalibReadout_CalibReadoutHeader_context_mSite);
   fChain->SetBranchAddress("context.mSimFlag", &context_mSimFlag, &b_CalibReadout_CalibReadoutHeader_context_mSimFlag);
   fChain->SetBranchAddress("context.mTimeStamp.mSec", &context_mTimeStamp_mSec, &b_CalibReadout_CalibReadoutHeader_context_mTimeStamp_mSec);
   fChain->SetBranchAddress("context.mTimeStamp.mNanoSec", &context_mTimeStamp_mNanoSec, &b_CalibReadout_CalibReadoutHeader_context_mTimeStamp_mNanoSec);
   fChain->SetBranchAddress("context.mDetId", &context_mDetId, &b_CalibReadout_CalibReadoutHeader_context_mDetId);
   fChain->SetBranchAddress("execNumber", &execNumber, &b_CalibReadout_CalibReadoutHeader_execNumber);
   fChain->SetBranchAddress("jobId.m_data[4]", jobId_m_data, &b_CalibReadout_CalibReadoutHeader_jobId_m_data);
   fChain->SetBranchAddress("randomState", &randomState, &b_CalibReadout_CalibReadoutHeader_randomState);
   fChain->SetBranchAddress("inputHeaders", &inputHeaders_, &b_CalibReadout_CalibReadoutHeader_inputHeaders_);
   fChain->SetBranchAddress("inputHeaders.m_entry", &inputHeaders_m_entry, &b_inputHeaders_m_entry);
   fChain->SetBranchAddress("inputHeaders.m_path", &inputHeaders_m_path, &b_inputHeaders_m_path);
   fChain->SetBranchAddress("site", &site, &b_CalibReadout_CalibReadoutHeader_site);
   fChain->SetBranchAddress("detector", &detector, &b_CalibReadout_CalibReadoutHeader_detector);
   fChain->SetBranchAddress("triggerNumber", &triggerNumber, &b_CalibReadout_CalibReadoutHeader_triggerNumber);
   fChain->SetBranchAddress("triggerType", &triggerType, &b_CalibReadout_CalibReadoutHeader_triggerType);
   fChain->SetBranchAddress("triggerTimeSec", &triggerTimeSec, &b_CalibReadout_CalibReadoutHeader_triggerTimeSec);
   fChain->SetBranchAddress("triggerTimeNanoSec", &triggerTimeNanoSec, &b_CalibReadout_CalibReadoutHeader_triggerTimeNanoSec);
   /*
   fChain->SetBranchAddress("nHitsAD", &nHitsAD, &b_CalibReadout_CalibReadoutHeader_nHitsAD);
   fChain->SetBranchAddress("timeAD", &timeAD, &b_CalibReadout_CalibReadoutHeader_timeAD);
   fChain->SetBranchAddress("chargeAD", &chargeAD, &b_CalibReadout_CalibReadoutHeader_chargeAD);
   fChain->SetBranchAddress("hitCountAD", &hitCountAD, &b_CalibReadout_CalibReadoutHeader_hitCountAD);
   fChain->SetBranchAddress("ring", &ring, &b_CalibReadout_CalibReadoutHeader_ring);
   fChain->SetBranchAddress("column", &column, &b_CalibReadout_CalibReadoutHeader_column);
   fChain->SetBranchAddress("nHitsAD_calib", &nHitsAD_calib, &b_CalibReadout_CalibReadoutHeader_nHitsAD_calib);
   fChain->SetBranchAddress("timeAD_calib", &timeAD_calib, &b_CalibReadout_CalibReadoutHeader_timeAD_calib);
   fChain->SetBranchAddress("chargeAD_calib", &chargeAD_calib, &b_CalibReadout_CalibReadoutHeader_chargeAD_calib);
   fChain->SetBranchAddress("hitCountAD_calib", &hitCountAD_calib, &b_CalibReadout_CalibReadoutHeader_hitCountAD_calib);
   fChain->SetBranchAddress("topOrBottom", &topOrBottom, &b_CalibReadout_CalibReadoutHeader_topOrBottom);
   fChain->SetBranchAddress("acuColumn", &acuColumn, &b_CalibReadout_CalibReadoutHeader_acuColumn);
   fChain->SetBranchAddress("nHitsPool", &nHitsPool, &b_CalibReadout_CalibReadoutHeader_nHitsPool);
   fChain->SetBranchAddress("timePool", &timePool, &b_CalibReadout_CalibReadoutHeader_timePool);
   fChain->SetBranchAddress("chargePool", &chargePool, &b_CalibReadout_CalibReadoutHeader_chargePool);
   fChain->SetBranchAddress("hitCountPool", &hitCountPool, &b_CalibReadout_CalibReadoutHeader_hitCountPool);
   fChain->SetBranchAddress("wallNumber", &wallNumber, &b_CalibReadout_CalibReadoutHeader_wallNumber);
   fChain->SetBranchAddress("wallSpot", &wallSpot, &b_CalibReadout_CalibReadoutHeader_wallSpot);
   fChain->SetBranchAddress("inwardFacing", &inwardFacing, &b_CalibReadout_CalibReadoutHeader_inwardFacing);
   fChain->SetBranchAddress("nHitsRpc", &nHitsRpc, &b_CalibReadout_CalibReadoutHeader_nHitsRpc);
   fChain->SetBranchAddress("rpcRow", &rpcRow, &b_CalibReadout_CalibReadoutHeader_rpcRow);
   fChain->SetBranchAddress("rpcColumn", &rpcColumn, &b_CalibReadout_CalibReadoutHeader_rpcColumn);
   fChain->SetBranchAddress("rpcLayer", &rpcLayer, &b_CalibReadout_CalibReadoutHeader_rpcLayer);
   fChain->SetBranchAddress("rpcStrip", &rpcStrip, &b_CalibReadout_CalibReadoutHeader_rpcStrip);
   fChain->SetBranchAddress("rpcFromRot", &rpcFromRot, &b_CalibReadout_CalibReadoutHeader_rpcFromRot);
   */
}

Bool_t CalibReadoutHeaderReader::Notify()
{
   // The Notify() function is called when a new file is opened. This
   // can be either for a new TTree in a TChain or when when a new TTree
   // is started when using PROOF. It is normally not necessary to make changes
   // to the generated code, but the routine can be extended by the
   // user if needed. The return value is currently not used.

   return kTRUE;
}

#endif // #ifdef CalibReadoutHeaderReader_cxx
